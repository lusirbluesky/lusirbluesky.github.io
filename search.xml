<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JVM专题]]></title>
    <url>%2F2018%2F03%2F19%2Fjvm-%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[#JVM常用优化参数 JVM常用参数说明，这里是以Java7为例（Java8有部分参数已失效）： ##1、参数说明： -Xms1024M：初始化堆内存大小（注意，不加M的话单位是KB）-Xmx1024M：最大堆内存大小 (1g=1024m)-XX:PermSize=256M：初始化类加载内存池大小-XX:MaxPermSize=256M：最大类加载内存池大小-XX:MaxnewSize=256M：表示新生代可被分配的内存的最大上限；当然这个值应该小于 -Xmx的值；-Xss512k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。 ##2、java 调用配置 1java -Xms1g -Xmx2g -XX:PermSize=256m -XX:MaxNewSize=256m -XX:MaxPermSize=256m -Xss512k -cp ./java-training.jar com.ganymede.oop.Client ##3、Tomcat的JVM配置 在tomcat_home/bin目录下找到catalina.bat 1set JAVA_OPTS= -Xms1g -Xmx2g -XX:PermSize=256m -XX:MaxNewSize=256m -XX:MaxPermSize=256m -Xss512k]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM专题]]></title>
    <url>%2F2018%2F03%2F19%2Fjvm-GC%2F</url>
    <content type="text"><![CDATA[#JVM常用算法 关于GC(Garbage Collection)的算法，常用的有以下几种： ##1、引用计数法 1) 老牌垃圾回收算法，通过引用计算来回收垃圾。引用计数器的实现很简单，对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的应用计数器的值为0，则对象A就不可能再被使用。 使用引用计数法的语言： Micsoft COM ActionScript3 Python 2) 引用计数法的问题: 引用和去引用伴随加法和减法，影响性能 很难处理循环引用 3) 由于引用计数法存在的问题，因此JVM并未使用该GC算法。 ##2、标记-清除算法 标记-清除算法是现代垃圾回收算法的思想基础。 标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。 ##3、标记-压缩算法 标记-压缩算法适合用于存活对象较多的场合，如老年代。它在标记-清除算法的基础上做了一些优化。和标记-清除算法一样，标记-压缩算法也首先需要从跟节点开始，对所有可达对象做一次标记。但之后，它并不简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。 与标记-除算法相比，标记-压缩算法处理了内存中的碎片，GC后让存活的内存放在连续的空间内，更好地利用了内存 ##4、复制算法 复制算法与标记-清除算法相比是一种相对高效的回收方法 不适用于存活对象较多的场合 如老年代。 复制算法将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收 复制算法常用于新生代 依据对象的存活周期进行分类，短命对象归为新生代，长命对象归为老年代。 根据不同代的特点，选取合适的收集算法 少量对象存活，适合复制算法，如新生代 大量对象存活，适合标记清理或者标记压缩，如老年代。 ##5、总结JVM使用的GC算法 1）老年代通常采用标记-压缩算法，如果老年代使用CMS回收器，则先使用标记-清除算法，然后再定时对内存进行压缩整理。 2）新生代通常使用复制算法]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spark]]></title>
    <url>%2F2018%2F03%2F12%2Fsparkonyarn%2F</url>
    <content type="text"><![CDATA[#Spark Spark的显著特点 分布式 基于内存（部分基于磁盘） 迭代式计算 ##SparkSQL能取代Hive吗？ 不能。Hive包含两部分：计算引擎和存储仓库。SparkSQL只能替换Hive的计算引擎，不能取代Hive。Hive是一个很好的数据仓库。 spark处理的数据来源：HDFS、HBase、Hive、DB、Local FS、S3等 spark处理的数据输出：HDFS、HBase、Hive、DB（s3等）、spark客户端（正在处理任务的机器Driver） ##RDD创建的方式 1.外部数据来源（如HDFS） 2.根据Scala集合 3.由其他RDD操作（Transformation操作会产生新的RDD，Action操作不会产生新的RDD） 数据会被RDD划分为一系列的Partitions，分配到每个Partition的数据属于一个Task的处理范畴 RDD为什么有很多不同的创建方式？ 因为Spark会基于不同的介质进行运算 ##Spark弹性分布式数据集RDD 弹性1： 自动进行内存和磁盘的数据存储读取的切换 弹性2：基于Lineage(血统)的高效容错（计算错误或丢失不会从头开始，第n个节点出错，会从第n-1个节点开始计算，极大提高了错误的恢复的速度） 弹性3：Task如果失败会自动进行特定次数的重试（默认4次）（只计算失败的阶段） 弹性4：Stage如果失败会自动进行特定次数的重试（默认3次）（只计算失败的分片） 弹性5：设置持久化和检查点（persistent和checkpoint，计算链条比较长或者计算比较笨重，考虑用checkpoint将数据都放在磁盘上，persist是在内存或磁盘进行数据复用。这是效率和容错的延伸点） 弹性6：数据调度弹性：DAGTask和资源管理无关 弹性7：数据分片的高度弹性（在计算过程中可能会产生很多数据碎片，这样一个partition会特别小，这么小的partition也要消耗一个线程去处理会降低处理效率，这时要考虑将很多小的partition合并成一个大的partition进行处理以提升效率；另外，如果内存不太多，但是每个partition特别大，数据block比较大，要考虑把他变成更小的分片这样让spark有更多的处理批次但是不会有OOM。数据分片提高并行度或降低并行度的弹性表现，而且数据处理的时候完全有数据本地性，并行度设置要人工处理。100w的数据分片变成1w个，不要调用repartition，要使用coalesce） 12345678910111213&gt; /**&gt; * Return a new RDD that has exactly numPartitions partitions.&gt; *&gt; * Can increase or decrease the level of parallelism in this RDD. Internally, this uses&gt; * a shuffle to redistribute data.&gt; *&gt; * If you are decreasing the number of partitions in this RDD, consider using `coalesce`,&gt; * which can avoid performing a shuffle.&gt; */&gt; def repartition(numPartitions: Int)(implicit ord: Ordering[T] = null): RDD[T] = withScope &#123;&gt; coalesce(numPartitions, shuffle = true)&gt; &#125;&gt; &gt; 123456789101112131415161718192021222324252627&gt; /**&gt; * Return a new RDD that is reduced into `numPartitions` partitions.&gt; *&gt; * This results in a narrow dependency, e.g. if you go from 1000 partitions&gt; * to 100 partitions, there will not be a shuffle, instead each of the 100&gt; * new partitions will claim 10 of the current partitions.&gt; *&gt; * However, if you're doing a drastic coalesce, e.g. to numPartitions = 1,&gt; * this may result in your computation taking place on fewer nodes than&gt; * you like (e.g. one node in the case of numPartitions = 1). To avoid this,&gt; * you can pass shuffle = true. This will add a shuffle step, but means the&gt; * current upstream partitions will be executed in parallel (per whatever&gt; * the current partitioning is).&gt; *&gt; * Note: With shuffle = true, you can actually coalesce to a larger number&gt; * of partitions. This is useful if you have a small number of partitions,&gt; * say 100, potentially with a few partitions being abnormally large. Calling&gt; * coalesce(1000, shuffle = true) will result in 1000 partitions with the&gt; * data distributed using a hash partitioner.&gt; */&gt; def coalesce(numPartitions: Int, shuffle: Boolean = false,&gt; partitionCoalescer: Option[PartitionCoalescer] = Option.empty)&gt; (implicit ord: Ordering[T] = null)&gt; : RDD[T] = withScope &#123;&gt; ///////////&gt; &#125;&gt; &gt; （task重试失败，整个计算阶段stage就会失败，计算阶段有很多并行的数据分片，这些分片的计算逻辑相同但是处理的数据不同，会再次提交stage只把失败的任务提交，已经成功的任务不会再次提交（这些成功的任务已经有结果输出，如果没有结果还是也会被提交）） spark的中间数据可以在内存也可在磁盘，不一定全部在内存 RDD在抽象上表示了元素的集合，内部包含数据，数据本身分区，在不同的节点上可以被并行操作，所以叫分布式数据集。最常用的sparkRDD的数据来源hadoop上，spark+hadoop黄金组合。 在开发或测试时，要启动start-history-server.sh，他会记录程序运行的信息，这样在session会话结束后还可以看曾经运行的程序的情况。可以在浏览器通过spark的地址+18080端口查看 1spark-shell --master spark://node01:7077 RDD通过spark context创建 spark context是集群的唯一的接口，你做一切工作都要基于spark context spark的一切操作皆RDD RDD可以从HDFS或者Hive表中获取数据 123456789101112131415161718192021#手动指定集群地址sc.textFile('hdfs://node01:9000/input')；#根据上下文自动获取集群地址val data = sc.textFile('/input')；data.toDebugString#Transformation算子（没有结果，lazy）-textFile#Action算子(给出结果，hungry)-countdata.count#spark界面的Tasks中的Locality_Level显示#NODE_LOCAL表示在磁盘#PROCESS_LOCAL表示在内存#ANY表示shuffle过的数据#计算不复杂的，数据大部分在磁盘上，对于迭代操作默认放在内存val flatted=data.flatMap(_.split(" "))#通过执行下面的语句，发现RDD是有依赖关系的flatted.toDebugStringval mapped = flatted.map(word=&gt;(word,1))mapped.toDebufStringval reduced = mapped.reduceByKey(_+_)reduced.toDebugStringreduced.saveAsTextFile("/output/data") ##SparkContext的作用？ 初始化spark应用程序运行所需要的核心组件，包括DAGScheduler、TaskScheduler、SchedulerBackend；同时还会负责spark程序往Master注册程序等。SparkContext是spark应用程序中最为重要的一个对象。 DAGScheduler：高层调度器，划分任务的不同阶段 TaskScheduler:接口，根据不同的资源调度模式 资源调度模式：local模式，standalone模式，yarn模式，mesos模式，ec2模式（云计算） RDD本身是泛型，是一系列的数据分片，每个分片是具体类型String或其他 data:RDD[String] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657##spark的每个步骤是不是都要做缓存？&gt; 不是每个步骤都会缓存，否则内存损耗太严重，这就和hadoop的mapreduce差不多了。&gt;&gt; 需要做缓存的情况：&gt;&gt; 1.计算步骤特别耗时&gt;&gt; 2.计算链条很长&gt;&gt; 3.shuffle之后&gt;&gt; （shuffle是从其他阶段拉数据，这时缓存，就不要重新shuffle）&gt;&gt; 4.checkpoint之前spark on yarn时，container是一个线程池一个操作可能产生一个RDD也可能产生多个RDD，如：textFile()产生了两个RDD（HadoopRDD和MapPartitionsRDD）HadoopRDD有key-行索引，value-行的内容MapPartitionsRDD没有key，只有valuereduceByKey产生了两个RDD（MapPartitionsRDD和ShuffledRDD）##Spark的partition数量怎么确定？什么时候需要repartition？&gt; 根据实际运行的状况设定，根据Core的个数，CPU的个数，集群的资源等。&gt;&gt; 需要repartition:&gt;&gt; - 数据碎片太多（要把多个碎片合并）&gt; - 要增加分片数量（OOM，内存不够）##ShuffledRDD之后还有一个MapPartitionsRDD，从保存数据到HDFS的角度讲MapPartitionsRDD？spark在计算的时候，把key暂时丢掉了，最后存储到HDFS上，要按照saveAsHadoopFile的要求的格式，将key补上，key不是偏移量，为什么需要它，因为hadoop需要```scaladef saveAsTextFile(path:String)&#123;this.map(x=&gt;(NullWritable.get(),new Text(x.toString)) .saveAsHadoopFile[TextOutputFormat[NullWritable, Text]](path)&#125;///////////////////val r = this.mapPartitions &#123; iter =&gt; val text = new Text() iter.map &#123; x =&gt; text.set(x.toString) (NullWritable.get(), text) &#125; &#125; RDD.rddToPairRDDFunctions(r)(nullWritableClassTag, textClassTag, null) .saveAsHadoopFile[TextOutputFormat[NullWritable, Text]](path) ##wordcount的第一个Stage和第二个Stage产生了哪些RDD？ stage1: HadoopRDD MapPartitionsRDD MapPartitionsRDD MapPartitionsRDD stage2: ShuffledRDD MapPartitionsRDD reduceByKey包含local reduce和global reduce两个部分 spark中master和worker管理的资源主要指内存和CPU spark的active状态的master指：现在正在管理集群并接受外界程序的程序提交请求和资源分配请求的master standby模式的master随时准备在active模式master挂掉后代替它管理系群 active模式的master挂掉后zookeeper自动切换 spark的HA可以是两台spark也可以是多台 ##zookeeper中的元数据信息包括哪些内容？ 所有worker、driver、application的元数据 ##spark中的资源分配粒度？ 粗粒度：一次性分配任务所需的全部资源 细粒度：分配一部分，用完重新申请 一般的是粗粒度 Spark中资源的分配是在程序注册时完成的，不是在具体的工作过程中申请分配的。 注册完成后资源被谁管理（standalone模式）：CoarseGrainedSchedulerBackend的子类SparkDeploySchedulerBackend driver到master注册并初始化 Spark的角色？ master worker driver：驱动程序的运行 executor：具体运行任务，计算数据 一个应用程序默认有一个DAGScheduler 一个worker节点默认为当前应用程序开启一个executor worker管理executor worker管理当前node的资源并接受master的指令来分配具体的计算资源executor（在新的进程中分配） ExecutorRunner相当于一个proxy，管理新分配的进程并监控该executor分配的进程的运行状况 worker会向master发送心跳信息（只有workerid），但不会向master汇报当前节点内存和CPU的信息。 master怎么知道worker节点的资源信息？ 应用程序在master上注册时，注册成功就会分配资源，分配的时候就记住了worker的资源状况，所有资源都是master分配的。 job是包含了一系列task的并行计算，在spark中一般由action触发，触发的时候前面会有一系列的RDD，action不会产生RDD，它会导致runjob。action前面的RDD是transaction级别的，lazy级别，没有计算。 spark的快不是因为基于内存，当前RDD回溯到前一个RDD（如果是窄依赖在内存中进行迭代，这是spark快的一个重要的原因，但spark快绝对不是因为基于内存），速度快有很多原因，最基本的是调度机制和容错机制。 窄依赖除了一对一的依赖还有range级别的依赖固定个数的父RDD的partition，依赖的固定个数不会随着计算规模的大小而改变，DAG就会变成宽依赖（依赖构成了DAG），如果是宽依赖DAGSchedule就会帮我们划分Stage，Stage内部是基于内存迭代的，也可以基于磁盘迭代。 Stage内部：计算逻辑完全一样，只是计算的数据不同罢了。 一个Application里面可以有多个不同的job，因为可以有不同的action，而一般一个action操作就会对应一个job。checkpoint也会导致job，在进行排序算法的时候进行range范围的划分也会触发job ##为什么不能再IDE集成开发环境中直接发布Spark程序到Spark集群？ 1.内存和cores的限制，默认spark程序的driver会在提交spark程序的机器上，所以如果在IDE中提交程序的话，那IDE机器必须非常强大 2.driver要指挥workers的运行并频繁的发生通信，如果开发环境IDE与spark集群不在同样的网络环境，就会出现任务丢失、运行缓慢等多种不必要的问题 3.这是不安全的 ##spark的底层是akka，为啥spark1.6.x内部实现通过rpc？ 以后可能不用akka了 现在是做了一层封装 spark2.0底层改用了netty driver能像master一样做HA吗？ client模式不行 cluster模式下，–spark-submit提交参数可指定–supervise后，如果driver挂掉后集群会自动帮你启动driver ##spark怎么知道分配多少资源？ 1.spark-env.sh和spark-default.sh 2.spark-submit提供的参数 3.程序中的sparkConf配置的参数 RDD：基于工作集的应用抽象 hadoop的mapreduce是基于数据集的处理 不论是基于工作集还是数据集，他们的共同特征：数据感知，容错，负载均衡 基于数据集的处理（代表是hadoop得到mapreduce）： 1.从物理存储设备加载数据 2.操作数据 3.写入物理设备 （spark的调度框架也是基于hadoop的mapreduce的一种实现，只是更细致，更高效） 不适合的场景： 不适合大量迭代（迭代就是每一步对数据进行相似的函数，机器学习或处理数据算法比较复杂） 不适合交互式查询（每次查询都要从磁盘读取数据，处理，写入磁盘） 致命点：基于数据流的方式不能复用曾经的结果或者中间计算结果 比如：1000个人对数据仓库进行并发查询， 查询完全一样，每次都要重新查询 查询中前10个步骤一样，后面几个步骤不同 spark的RDD是基于工作集 RDD（Resilient Distribute Dataset）：上面总结五点弹性 RDD就是一个List或者Array RDD是分布式函数式编程的抽象（基于RDD的编程一般都会产生高阶函数，简单的可能不会产生） 每步操作都是基于RDD操作，RDD又是只读分区的集合，但是每步操作都会改变数据（map,reduceBykey…），这时产生中间结果怎么办？不能立即计算，lazy级别，只标记不计算。最后action算子操作（回溯）触发所有链条函数执行，函数展开，计算结果。 spark比hadoop的位置感知好很多，hadoop进行partitioner之后就不管reducer在哪里了，但是spark进行partitioner，进行下一步stage操作时会确定位置 spark streaming用到窗口机制，为什么要checkpoint？ checkpoint要将数据或结果保存到磁盘上 因为要经常用到以前的东西 如果一个stage有1000个步骤，spark不会产生999次中间结果，默认只会产生一次中间结果，hadoop的mapreduce会产生999次中间结果。 每步操作都是基于RDD操作，RDD又是只读分区的集合，但是每步操作都会改变数据（map,reduceBykey…），这时产生中间结果怎么办？不能立即计算，lazy级别，只标记不计算。 数据量越大，计算步骤越多，spark的优势越明显。 spark1.3版本里程碑，dataframe的革命 spark1.2.x版本前，由于shuffle问题，spark不适合大规模计算，有规模限制，但是之后任意规模，可以自定义shuffle插件 常规容错的方式：数据检查点（每次拷贝跨网络传输，消耗存储）和记录数据更新操作（每次数据变化都记录，复杂，难处理重新计算） ##Spark的容错：通过RDD记录数据更新的方式为何高效？ 1.RDD不可变+Lazy级别构成了链条 2.RDD的写操作是粗粒度（提高效率，简化复杂度），RDD的读操作可粗粒度可细粒度（RDD的大多数场景都是粗粒度） 从第900步恢复的前提是要在第900步持久化？ 第900步是上一个stage的结束或者第900步进行了checkpoint/persist持久化。（stage结束会写入磁盘） 没有中间结果不需要进行维护 RDD的数据分片上的一系列的计算逻辑都是一样的 Tachyon解决南北（不同）数据中心数据不同步问题 Spark的所有子框架都是基于RDD的 spark要做一体化多元化的通用数据处理框架，兼容一切操作系统，文件格式，数据库 spark不能处理的问题：实时事务性处理 spark要统一数据计算领域，除了实时事务性处理 ##RDD的缺陷 不支持细粒度的更新操作 不支持增量迭代计算 ##RDD为什么有很多不同的创建方式？ 因为Spark会基于不同的介质进行运算 ##Spark和Hadoop有关系吗？ 没有。Spark运行在Hadoop之上，hadoop作为spark的数据存储来源的时候有关系。 ##RDD的创建方式 三种最基本的方式创建： 1.使用程序中的集合创建RDD 2.使用本地文件系统创建RDD 3.使用HDFS创建RDD 其他创建方式： 4.基于DB创建RDD 5.基于NoSQL，如HBase 6.基于S3创建 7.基于数据流创建RDD（如spark streaming） 通过集合创建RDD的实际意义？ 测试 使用本地文件系统创建RDD的作用？ 测试大量数据文件 使用HDFS创建RDD？ 生产环境最常用的RDD创建方式 ##Spark最佳实践 并行度设置 单个core可以承载2-4个partition（32core可以承载64-128partition） 任务的数据量大小及复杂程度涉及到内存和CPU ##RDD的操作有几种？ 三种。 transformation 针对已有的RDD创建一个新的RDD action 得到最终结果 controller 控制算子 cache，persist，checkpoint（cache是一种特殊的persist） ##谈谈Shuffle 什么是shuffle？ 洗牌，需要shuffle的关键原因是：某种需要共同特征的数据需要最终汇聚到 一个计算节点上进行计算。 什么时候会产生shuffle？ 运行task的时候才会产生shuffle（shuffle已经融合在spark的算子中了） shuffle可能面临的问题？ 1.数据量非常大（网络传输） 2.数据如何分类，即如何partition 分为hash partition，sort partition和钨丝计划 3.负载均衡（数据倾斜） 4.网络传输效率，需要在压缩与解压缩之间权衡，序列化和反序列化 说明：具体的task进行计算的时候，尽一切可能使数据具备process locality的特性；退而求其次，增加数据分片，减少每个task处理的数据量 persist或cache的价值不如出错后重新在内存算一遍（cache的风险OOM或空间被别人占用） 内存中重新计算比将结果持久化到磁盘然后从磁盘读结果可能更快 读磁盘IO是高风险的，读内存风险降低很多 一般不持久化中间结果，数据丢失重新计算依赖的RDD，在一个Stage内部鼓励这样做 如果产生shuffle，会进行网络通信，这时肯定要持久化，一般持久化到磁盘，也可以持久化的内存等 hash shuffle 1.key不能是Array(如果是array，不能友好的计算hashcode) 2.hash shuffle不需要排序（理论上速度快，性能好），此时从理论上讲节省了hadoop mapreduce进行shuffle排序的时间浪费，因为实际生产环境有大量不需要排序的shuffle 思考：不需要排序的hash shuffle一定比需要排序的sorted shuffle速度快？ 不一定。 数据规模小时，hash shuffle会比sorted shuffle快（很多） 数据量大时，sorted shuffle一般都会比hash shuffle快（很多） 因为hash方式会有key，句柄，有一些小文件等，磁盘和内存会变成瓶颈。sorted会极大的节省内存和对磁盘的访问，更有利于大规模的数据计算。 3.除了最后一个stage里面的任务是result task，其他前面的都是shuffle map task。每个shufflemaptask会根据key的hash值计算出当前的key需要的partition，然后把决定后的结果写入单独的文件。。。。。。。。。 注意：shuffle操作绝大多数情况下要经过网络，如果mapper和reducer在同一台机器上，此时只需读取本地磁盘。 hash shuffle的两大死穴： shuffle前会在磁盘上产生海量的小文件，此时会产生大量耗时低效的IO操作； 内存不共用！由于内存中需要保存海量文件操作句柄和临时缓存信息，如果数据处理规模比较庞大的话，内存不可承受，出现OOM等问题。 为了改善上述问题（同时打开过多文件导致Write Handler内存使用过大以及产生过度文件导致大量随机读写带来的低效磁盘IO），spark推出了consalidate机制，合并小文件。此时shuffle时产生的文件的数量为cores*R，对于shuffle map task的数量明显多于同时可用的并行cores的数量时，shuffle产生的文件数量会大幅度减少，会极大降低OOM可能 为什么使用sort-based shuffle？ 1.shuffle一般包含两阶段的任务，产生shuffle数据的阶段（map阶段）和使用shuffle数据的阶段 （reduce阶段） sort-based shuffle 归并排序]]></content>
      <categories>
        <category>bigdata</category>
      </categories>
      <tags>
        <tag>bigdata</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spark性能优化]]></title>
    <url>%2F2018%2F03%2F12%2Fspark%2F</url>
    <content type="text"><![CDATA[Spark性能优化##Spark性能优化的10大问题及其解决方案 问题1：reduce task数目不合适 解决方案： 需要根据实际情况调整默认配置，调整方式是修改参数spark.default.parallelism。通常的，reduce数目设置为core数目的2-3倍。数量太大，造成很多小任务，增加启动任务的开销；数目太小，任务运行缓慢。所以要合理修改reduce的task数目即spark.default.parallelism 问题2：shuffle磁盘IO时间长 解决方案： 设置spark.local.dir为多个磁盘，并设置磁盘的IO速度快的磁盘，通过增加IO来优化shuffle性能； 问题3：map|reduce数量大，造成shuffle小文件数目多 解决方案： 通过设置spark.shuffle.consolidateFiles为true，来合并shuffle中间文件，此时文件数为reduce tasks数目； 问题4：序列化时间长、结果大 解决方案： spark默认使用JDK 自带的ObjectOutputStream，这种方式产生的结果大、CPU处理时间长，可以通过设置spark.serializer为org.apache.spark.serializer.KeyoSerializer。 另外如果结果已经很大，那就最好使用广播变量方式了，结果你懂得。 问题5：单条记录消耗大 解决方案： 使用mapPartition替换map，mapPartition是对每个Partition进行计算，而map是对partition中的每条记录进行计算； 问题6 : collect输出大量结果时速度慢 解决方案： collect源码中是把所有的结果以一个Array的方式放在内存中，可以直接输出到分布式的文件系统，然后查看文件系统中的内容； 问题7: 任务执行速度倾斜 解决方案： 如果数据倾斜，一般是partition key取得不好，可以考虑其他的并行处理方式，并在中间加上aggregation操作；如果是Worker倾斜，例如在某些Worker上的executor执行缓慢，可以通过设置spark.speculation=true 把那些持续慢的节点去掉； 问题8: 通过多步骤的RDD操作后有很多空任务或者小任务产生 解决方案： 使用coalesce或者repartition去减少RDD中partition数量； 问题9：Spark Streaming吞吐量不高 可以设置spark.streaming.concurrentJobs 问题10：Spark Streaming 运行速度突然下降了，经常会有任务延迟和阻塞 解决方案： 这是因为我们设置job启动interval时间间隔太短了，导致每次job在指定时间无法正常执行完成，换句话说就是创建的windows窗口时间间隔太密集了； 问题11：receiver个数设置 ##Spark SQL之Join]]></content>
      <categories>
        <category>bigdata</category>
      </categories>
      <tags>
        <tag>bigdata</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hive]]></title>
    <url>%2F2018%2F03%2F12%2Fhive%2F</url>
    <content type="text"><![CDATA[#hive 安装 自行下载安装包 上传hive-1.2.1.tar.gz包到/export/softwares/目录 解压hive-1.2.1.tar.gz包到/export/servers/目录 1tar -zxvf /export/softwares/hive-1.2.1.tar.gz /export/servers/ 安装mysql数据库 推荐yum 在线安装 修改配置文件 12345# 配置HIVE_HOME环境变量vi conf/hive-env.sh # 配置其中的$hadoop_home# Set HADOOP_HOME to point to a specific hadoop install directoryexport HADOOP_HOME=/export/servers/hadoop 12# 配置元数据库信息vi conf/hive-site.xml 1234567891011121314151617181920212223242526&lt;!--添加如下内容：--&gt;&lt;configuration&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt; &lt;value&gt;jdbc:mysql://localhost:3306/hive?createDatabaseIfNotExist=true&lt;/value&gt; &lt;description&gt;JDBC connect string for a JDBC metastore&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt; &lt;description&gt;Driver class name for a JDBC metastore&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt; &lt;value&gt;root&lt;/value&gt; &lt;description&gt;username to use against metastore database&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt; &lt;value&gt;sql&lt;/value&gt; &lt;description&gt;password to use against metastore database&lt;/description&gt; &lt;/property&gt;&lt;/configuration&gt; 安装hive和mysql完成后，将mysql的连接jar包拷贝到$HIVE_HOME/lib目录下，如果出现没有权限的问题，在mysql授权(在安装mysql的机器上执行) 1234mysql -uroot -p#(执行下面的语句 *.*:所有库下的所有表%：任何IP地址或主机都可以连接)GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;root&apos; WITH GRANT OPTION;FLUSH PRIVILEGES; Jline包版本不一致的问题 12# 需要拷贝hive的lib目录中jline.2.12.jar的jar包替换掉hadoop中的/export/servers/hadoop/share/hadoop/yarn/lib/jline-0.9.94.jar 启动 hive交互shell bin/hive hive JDBC服务(参考java jdbc连接mysql) hive启动为一个服务器，来对外提供服务 123456&gt; #启动hiveserver2&gt; # 前台启动&gt; bin/hiveserver2&gt; # 后台启动&gt; nohup bin/hiveserver2 1&gt;/var/log/hiveserver.log 2&gt;/var/log/hiveserver.err &amp;&gt; 12345678&gt; # beeline连接&gt; # 启动成功后，可以在别的节点上用beeline去连接&gt; bin/beeline -u jdbc:hive2://node01:10000 -n root&gt; #或者&gt; bin/beeline ! connect jdbc:hive2://node01:10000&gt; # 用户名密码为hiveserver2所在节点的linux用户名密码&gt; # 如果不做特别权限配置，只需要输入用户名，密码直接回车即可&gt; hive命令 123# 在linux环境下执行hive sql语句，执行完成回到linux环境# hive -e 'sql'bin/hive -e 'select * from t_test' 提示：hive的使用依赖hadoop环境，所以要启动hdfs和yarn ##hive基本操作 ###DDL操作 sql 创建表加载数据 123#数据文件user.txt#1 tom 21#2 david 23 123--创建数据库lusircreate database lusir;use lusir; 123--创建数据表t_usercreate table t_user(id int,name string,age int)row format delimited fields terminated by '\t' 1234567#上传到对应的数据表下建立映射关系hadoop fs -put /root/data/user.txt /user/hive/warehouse/lusir.db/t_user#或者通过加载数据load data local inpath '/root/data/user.txt'[overwrite] into table t_user;#查询select * from t_user; 12345--jerry beijing,tianjin--tom shanghai,nanjingcreate table complex_array(name string,work_locations array&lt;string&gt;)row format delimited fields terminated '\t'collection items terminated by ','; 1234567--1,zhangsan,唱歌:非常喜欢-跳舞:喜欢-游泳:一般般--2,lisi,打游戏:非常喜欢-篮球:不喜欢create table t_map(id int,name string,hobby map&lt;string,string&gt;)row format delimited fields terminated by ','collection items terminated by '-'map keys terminated by ':' ; 创建分区表 123456789101112--创建分区表--单分区create table t_user(id int,name string)partitioned by (country string)row format delimitedfields terminated by ',';、--注释：分区字段不能和表中实际字段重名，否则报错--FAILED: SemanticException [Error 10035]: Column repeated in partitioning columns--加载本地数据load data local inpath '/root/data/partition.txt' into table t_user partition(country='china');--注释：加载本地数据时，数据文件必须在hiveserver2所在节点的本地存在--注释：hdfs上对应的数据库文件夹下的新文件夹为country=china 123--查看表信息desc t_users;describe t_users; 123456789101112--创建分区表--双分区create table day_hour_table(id int,name string)partitioned by (dt string,hour string)row format delimitedfields terminated by ',';--加载(hdfs数据)load data inpath '/hivedata/double.txt' into table day_hour_table partition(dt='2018-02-26',hour='14');--查看分区表的分区信息show partitions day_hour_table;--查看非分区表的分区信息（报错）show partitions ttt; 创建分桶表 12345#指定开启分桶set hive.enforce.bucketing = true;set mapreduce.job.reduces=4;#默认值set mapreduce.job.reduces=-1#set mapreduce.job.reduces与mapreduce的reducetask的个数（分区数）相同 12345678910111213141516--创建分桶表create table stu_buck(Sno int,Sname string,Sex string,Sage int,Sdept string)clustered by(Sno)--sorted by(Sno DESC)into 4 bucketsrow format delimitedfields terminated by ',';--加载数据不会分桶（数据展现就像普通表）load data local inpath '/root/data/buck.txt' into table stu_buck;--分桶表导入数据--借助导入另一张表数据insert overwrite table stu_buckselect * from student cluster by(Sno);--直接导入自身数据insert overwrite table stu_buckselect * from stu_buck cluster by(Sno); 内部表vs外部表 12345678--建内部表create table student(Sno int,Sname string,Sex string,Sage int,Sdept string)row format delimitedfields terminated by ',';--建外部表create external table student_ext(Sno int,Sname string,Sex string,Sage int,Sdept string)row format delimitedfields terminated by ',' location '/stu'; 1234--内、外部表加载数据：load data local inpath '/root/hivedata/students.txt' overwrite into table student;load data inpath '/stu' into table student_ext; like创建表 12--LIKE 允许用户复制现有的表结构，但是不复制数据create table like_tbl like t_user; ###DML操作 insert查询语句 12345678910111213141516171819--多重插入：create table source_table (id int, name string)row format delimitedfields terminated by ',';create table test_insert1 (id int)row format delimitedfields terminated by ',';create table test_insert2 (name string)row format delimitedfields terminated by ',';from source_tableinsert overwrite table test_insert1select idinsert overwrite table test_insert2select name; 动态分区插入 1234#是否开启动态分区功能，默认false关闭。set hive.exec.dynamic.partition=true;#动态分区的模式，默认strict，表示必须指定至少一个分区为静态分区#nonstrict模式表示允许所有的分区字段都可以使用动态分区。set hive.exec.dynamic.partition.mode=nonstrict; 需求：将dynamic_partition_table中的数据按照时间(day)，插入到目标表d_p_t的相应分区中。 1234567#dynamic_partition_table.txt2015-05-10,ip12015-05-10,ip22015-06-14,ip32015-06-14,ip42015-06-15,ip12015-06-15,ip2 123456789101112131415--原始表：create table dynamic_partition_table(day string,ip string)row format delimitedfields terminated by ",";--加载数据load data local inpath '/root/hivedata/dynamic_partition_table.txt' into table dynamic_partition_table;--目标表：create table d_p_t(ip string) partitioned by (month string,day string);--动态插入：insert overwrite table d_p_t partition (month,day) select ip,substr(day,1,7) as month,day from dynamic_partition_table;--动态分区是通过位置来对应分区值的。原始表select 出来的值和输出partition的值的关系仅仅是通过位置来确定的，和名字并没有关系。 查询结果导出到文件系统 123456--将查询结果保存到指定的文件目录（可以是本地，也可以是hdfs）insert overwrite local directory '/home/hadoop/test'select * from t_p;insert overwrite directory '/aaa/test'select * from t_p; 小结 hive数据存储在hdfs的/user/hive/warehouse路径下 请注意查看hive-site.xml中的配置 数据库，数据表，分区，分桶在hdfs中以文件夹的形式存在，数据以文件的形式存在 元数据默认存储在内置的derby数据库中，在哪个路径下启动hive都会产生一份元数据，带来了很多不便。为了解决这种问题，用mysql中永久保存元数据信息，以免每次启动hive都要重新创建。 123456789&gt; # 默认数据库路径（default数据库）&gt; /user/hive/warehouse/&gt; # 自建数据库路径&gt; /user/hive/warehouse/lusir.db&gt; # 自建数据库路径下的表&gt; /user/hive/warehouse/lusir.db/test&gt; # 自建数据库路径下的表下的数据文件（0,1或多个文件）&gt; /user/hive/warehouse/lusir.db/test/data.txt&gt; &gt; hive中的表实际上是hdfs中指定路径下的数据文件中的结构化数据与mysql中的元数据信息映射之后的结果 完美产生映射的必要条件 表的字段个数和类型跟结构化数据中的字段个数和类型一致 在建表的时候指定本次映射的结构化数据中的分隔符是什么 默认分隔符“\001”，在数据文件直接手动敲出无效，要在vim编辑环境下用ctrl+v然后ctrl+a得到^A即为默认分隔符。 1234&gt; &gt; #指定分隔符&gt; &gt; #指定分隔符为\t&gt; &gt; row format delimited fields terminated by '\t'&gt; &gt; &gt; 后续所有针对结构化数据的操作分析，转化成了对这个hive中表的分析 sql由hive帮我们转化成了MapReduce程序 分区 hive中的分区字段不能够是表当中已经存在的字段 分区的字段是个虚拟的字段不存放任何数据 它的值来自于你装载分区表数据的时候指定的 它的效果就是在表的文件夹下面又创建了子文件夹 目的：进一步划分数据，避免查询对全表扫描（只扫描指定的分区即可）即提高查询效率 分桶 分桶操作之前需要手动开启分桶的功能同时指定分为几个桶 hive中的分桶（分簇）字段必须是表当中已经存在的字段 针对分桶表的数据导入：data ```的方式不行，原因在于load数据本质相当于由hive帮你去```hadoop fs -put xxx数据文件```这没有执行**MR**程序，不会分桶123456&gt; - 分桶表的数据插入要使用 insert+select方式：插入的数据来自于查询语句，本质是分桶一定要执行**MR**程序，对应**MR**中Partitioner&gt; - 默认分桶规则按照你指定的分桶字段**模除以**（%）设置的分桶个数&gt;&gt; ```shell&gt; set mapreduce.job.reduces=？&gt; &gt; 分桶虽然也是针对数据进行更加细致化的划分，但是更多的是用来（Map端连接操作）提高多表之间的join查询效率 需要join的字段在各自表中进行分桶 避免了全表笛卡尔积，可以直接匹配，所以更加高效 在数据量足够大的情况下，分桶比分区更高的查询效率 索引分区分桶小结 索引和分区最大的区别就是索引不分割数据库，分区分割数据库。 索引其实就是拿额外的存储空间换查询时间，但分区已经将整个大数据库按照分区列拆分成多个小数据库了。 分区和分桶最大的区别就是分桶随机分割数据库，分区是非随机分割数据库。 因为分桶是按照列的哈希函数进行分割的，相对比较平均；而分区是按照列的值来进行分割的，容易造成数据倾斜。 其次两者的另一个区别就是分桶是对应不同的文件（细粒度），分区是对应不同的文件夹（粗粒度）。 注意：普通表（外部表、内部表）、分区表这三个都是对应HDFS上的目录，桶表对应是目录里的文件 推荐大家学习的时候HIVE、HDFS、MYSQL三者结合一起看，更容易理解其中的原理。 HIVE-索引、分区和分桶的区别 hive中的表名和字段名对大小写不敏感 hive中类sql语句要以分号标识一个语句的结束 加载本地数据时，数据文件必须在hiveserver2所在节点的本地存在 12&gt; load data local inpath '' into table tablename&gt; &gt; 加载集群数据，节点必须开启hiveserver2且能够访问hdfs集群且hdfs指定路径存在对应的数据文件 12&gt; load data inpath '' into table tablename&gt; &gt; 分区表是在目录级别进行划分 分桶表是在文件级别进行划分 分区用于创建表，加载表，插入表 分桶用于创建表，查询表 加载数据注意： 123456&gt; #使用local会将数据文件复制到hdfs的hive对应数据表&gt; load data local inpath '/root/data/1.txt' into table tt;&gt; #不用local而直接加载hdfs数据会将数据文件移动到hive对应数据表&gt; #当映射路径既有文件又有文件夹时，文件会全部映射到hive对应表中，文件夹如果为空会报错&gt; load data inpath '/hive/' overwrite into table tt;&gt; &gt; hive命令行中可执行hive sql命令，hdfs命令和linux shell命令 12345&gt; --hive中执行hdfs命令&gt; dfs -ls /&gt; --hive中执行linux shell命令&gt; !ls /root/&gt; &gt; hive加载数据时不做类型检查，查询时检查 hive中select查询插入数据注意字段位置 外部分区表需要先添加分区才能看到数据 导出数据 导出路径不存在自动创建数据导出到本地支持指定分隔符数据导出到hdfs不支持指定分隔符 12345678910&gt; --数据导出到本地&gt; insert into|overwrite local directory '/root/data/'&gt; row format delimited fields terminated by '\t'&gt; select name,addr&gt; from test;&gt; --数据导出到hdfs&gt; insert into|overwrite directory '/hdfs/data/'&gt; select name,addr&gt; from test;&gt; &gt; 1234&gt; #hadoop命令导出数据&gt; hadoop fs -get&gt; hadoop fs -text &gt; &gt; 123&gt; #shell命令加管道&gt; #第三方工具Sqoop导出数据到本地&gt; &gt; 一个表一天产生的分区数最好不要太多 动态分区 12345678910111213141516&gt; #是否开启动态分区功能，默认false关闭。&gt; set hive.exec.dynamic.partition=true;&gt; #动态分区的模式，默认strict，表示必须指定至少一个分区为静态分区#nonstrict模式表示允许所有的分区字段都可以使用动态分区。&gt; set hive.exec.dynamic.partition.mode=nonstrict;&gt;&gt; create table t_part(name string)&gt; partitioned by (val String)&gt; row format delimited&gt; fields terminated by '\t'&gt; lines terminated '\n'&gt; stored as teextfile;&gt;&gt; insert overwrite table t_part partition(val)&gt; select name,addr as val&gt; from test;&gt; &gt; 1234&gt; alter table test rename to newtable;&gt; alter table test change column c1 c2 int comment '年龄';&gt; alter table test add columns (c1 string comment '',c2 long comment '');&gt; &gt; hive不支持union，支持union all count(*)&amp;count(1) count(*)当该记录的所有值都不为NULL才计数，都为NULL不计数 count(1)不管记录中是否有NULL，都计数 但是，HQL中count(*),count(1),count(column)的区别一文中写的却不同，该文结论如下： count(*)：所有行进行统计，包括NULL行 count(1)：所有行进行统计，包括NULL行 count(column)：对column中非Null进行统计 count(distinct column)：对column中非Null进行去重统计 where语句是在map阶段执行 一般不在大数据中使用order by，将数据处理完成后，导出到关系型数据库，在关系型数据库中使用order by select后面的非聚合列必须出现在group by中，否则报错 having是在reduce端执行的，在reduce端执行完聚合操作之后进行的 优化group by参数： 12345&gt; --开启两个job&gt; set hive.groupby.skewindata=true;&gt; --数据倾斜优化&gt; set mapred.reduce.tasks=5;&gt; &gt; 执行join时存在数据倾斜，设置优化参数： 12&gt; set hive.optimize.skewjoin=true;&gt; &gt; 一般的join操作是在reduce端进行join的，mapjoin是一种优化操作，在map端进行join操作，优化join的查询。 什么是mapjoin？ 在map端把小表加载到内存，然后读取大表再和内存中的小表进行连接操作 使用了分布式缓存技术 mapjoin的优缺点？ 优点： 不消耗集群的reduce资源（reduce相对紧缺时） 减少reduce操作，加快程序执行 降低网络负载 缺点： 占用部分内存，所以加载到内存中的表不能过大，因为每个计算节点都会加载一次（最好几M到几十M） 生成较多的小文件（与Map的任务数有关） 使用mapjoin的参数设置？ 配置参数，hive根据sql自动选择使用commonjoin或mapjoin 123456&gt; &gt; --Whether Hive enables the optimization about converting common join into mapjoin based on the input file size. (Note that hive-default.xml.template incorrectly gives the default as false in Hive 0.11.0 through 0.13.1.)&gt; &gt; set hive.auto.convert.join=true;&gt; &gt; --Default Value: 25000000&gt; &gt; --The threshold (in bytes) for the input file size of the small tables; if the file size is smaller than this threshold, it will try to convert the common join into map join.&gt; &gt; hive.mapjoin.smalltable.filesize=25mb&gt; &gt; &gt; 手动指定使用map join 123&gt; &gt; select /*+mapjoin(n)*/m.col,m.col2,n.col3&gt; &gt; from m join n on m.col=n.col;&gt; &gt; &gt; map join的使用场景？ 关联操作中有一张表非常小 不等值的连接操作 分桶操作的好处？ 存在join查询时更高效 取样更高效 123456&gt; --分桶查询参数设置&gt;&gt; --分桶取样&gt; select * from bucket_user&gt; tablesample(bucket 1 out of 2 on id);&gt; &gt;&gt; distribute by 和sort by distribute分散数据 distribute by col 按照col列把数据分散到不同的reduce sort排序 sort by col 按照col列把数据排序 两者结合使用可以确保每个reduce的输出都是有序的，但不保证全局的有序性 1234&gt; select col1,col2 from m&gt; distribute by col1&gt; sort by col1 asc,col2 desc;&gt; &gt; distribute by与group by 都是按照key划分数据 都使用了reduce操作 唯一的区别： distribute by单纯的分散数据 group by把相同key的数据聚集到一起，后续必须是聚合操作 order by和sort by order by是全局排序 sort by只确保每个reduce上输出的数据有序，如果只有一个reduce，那就和order by作用一样 distribute by和sort by的应用场景 map输出的文件大小不均 reduce输出的文件大小不均 小文件过多 文件超大 hive只支持union all不支持union union all使用注意： union all连接的子表不允许有别名 合并字段的名字、类型、字段个数要一样 如果要从合并后的表中查数据，那合并的表必须有别名 一般的子查询需要别名 union all执行比较快，只有map任务，没有reduce任务 1234567&gt; --UDTF&gt; --一列转多行&gt; select id,adid&gt; from winfunc&gt; lateral view explode(split(type,'B')) tt as adid;&gt; --explode(array或map)&gt; &gt; 正则表达式的贪婪匹配及防止贪婪匹配 UDF：用户自定义函数 针对单条记录 创建函数 自定义一个java类 继承UDF类 重写evaluate方法 打jar包 hive执行add jar hive执行创建模板函数 hql中使用 UDAF：用户自定义聚合函数 自定义实现两步走： 编写resolver类进行类型检查和操作符重载 编写evaluator类实现UDAF的逻辑 mode表示了UDAF在mapreduce的各个阶段 partial1（map） partial2（combiner） final（reduce） complete（只有map没有reduce时执行） 理解了mode的含义就理解了hive的UDAF运行流程 mapreduce阶段调用函数 map init()、iterate()、terminatePartial() combiner merge()、terminatePartial() reduce init()、merge()、terminate() ##Hive SQL优化 hive优化分为： 表优化 sql优化 job优化 map优化 shuffle优化 reduce优化 1.对于oracle等关系型数据库中的sql语句，既有join on又有where时，它会自动优化先执行where中的条件过滤之后再执行join on关联其他表；但是hive不同，hive会先执行join on关联表然后再执行where条件 2.对于数据量比较大的情况下，count(distinct)优化 优化前： 123&gt; --执行一个job&gt; select count(distinct id) from tablename;&gt; &gt; 优化后： 12345&gt; --执行两个job&gt; select count(1) from (select distinct id from tablename) tmp;&gt; --或&gt; select count(1) from (select id from tablename group by id) tmp;&gt; &gt; 3. 优化前 12&gt; select a,sum(b),count(distinct c),count(distinct d) from test group by a;&gt; &gt; 优化后 1234567891011&gt; select a,sum(b) as b,count(c) as c,count(d) as d from (&gt; select a,0 as b,c,null as d from test&gt; group by a,d&gt; union all&gt; select a,0 as b,null as c,d from test &gt; group by a,c&gt; union all&gt; select a,b,null as c,null as d from test&gt; ) tmp&gt; group by a;&gt; &gt; 4.Hive的优化目标 在有限的资源下高效执行。 常见问题 数据倾斜 Map数设置 Reduce数设置 其他 5.explain extended sql可以查看该hive sql的执行语法树，有几个stage，map阶段，reduce阶段，map阶段扫描的哪些数据等 6.job优化 压缩优化 压缩效果好的占用磁盘空间小，但是会消耗更多的CPU时间 对于中间job结果，选择轻度压缩(SnappyCodec)，最终结果可以选择重度压缩(GzipCodec)，压缩类型一般为block 7.map优化 文件大小太大，设置参数 小文件数量过多，设置参数在map阶段合并小文件 map端聚合即combiner 12&gt; set hive.exec.aggr=true;&gt; &gt; 推测执行 shuffle优化配置参数（溢出比，压缩） reduce优化 需要reduce操作的查询 聚合函数 sum,count,distinct… 高级查询 group by,join,distribute by,cluster by… order by比较特殊，只需一个reduce 开启推测执行参数 ##hive中的哪些SQL会执行MR? ##hive多表查询的条件写在join里好还是用子查询？ 两个表关联查询，是把条件都写join on里好？select a. from a join b on ( a.id = b.id and a.a = 2 and b.c = 3)还是写成子查询的形式比较快？select a. from a join (select b.* from b where b.c = 3) c on (a.id = c.id) where a.a = 2 或者hive其实两种形式都会优化，所以速度差不多？ 分情况吧。 1、如果不存在数据倾斜，应该是第一种，从执行逻辑计划来看，这种方式会在reduce时候过滤掉不满足on 条件中的数据，而第二种方式在join之前会有一次数据读取处理过程，多一次磁盘IO过程，因此第一种方式时间短一些 2、若是join的两张表在关联时因笛卡儿积产生数据倾斜，第一种方式处理时间估计就比较久了，on条件过滤也是挽救不了，需要采取其他的方式进行优化 HQL编写时为了处理数据，在了解数据的基础上对语句优化更有方向 ##创建一个分区且排序的表(???????????????) create table stu_buck(Sno int,Sname string,Sex string,Sage int,Sdept string)partitioned by (dt string,country string)clustered by(Sno) into 3 bucketsrow format delimitedfields terminated by ‘,’; load data inpath ‘/hive0227/students.txt’ overwrite into table stu_buck partition(dt=’2018-02-27’,country=”china”); insert overwrite table stu_buck partition(dt=’2018-02-27’,country=”china”)select * from stu_buck; ==================create table stu_buck1(Sno int,Sname string,Sex string,Sage int,Sdept string)partitioned by (dt string,country string)clustered by(Sno) into 3 bucketsrow format delimitedfields terminated by ‘,’; insert overwrite table stu_buck1 partition(dt=’2018-02-27’,country=”china”)select Sno,Sname,Sex,Sage,Sdept from stu_buck;最终生成1个文件（只有map阶段） insert overwrite table stu_buck1 partition(dt=’2018-02-27’,country=”china”)select Sno,Sname,Sex,Sage,Sdept from stu_buck cluster by(sno);最终生成三个文件（两个阶段（一次mapreduce+一次mapreduce））两个阶段的maptask数与reducetask数不一样 select * from stu_buck1 tablesample(bucket 1 out of 3 on sno); set mapreduce.job.reduces=3;insert overwrite table stu_buck1 partition(dt=’2018-02-27’,country=”china”)select Sno,Sname,Sex,Sage,Sdept from stu_buck cluster by(sno);最终生成三个文件（两个阶段（一次mapreduce+一次mapreduce））两个阶段的maptask数与reducetask数不一样 set mapreduce.job.reduces=2;insert overwrite table stu_buck1 partition(dt=’2018-02-27’,country=”china”)select Sno,Sname,Sex,Sage,Sdept from stu_buck cluster by(sno);最终生成三个文件（两个阶段（一次mapreduce+一次mapreduce））两个阶段的maptask数与reducetask数不一样 在hive命令行查看hdfs上的文件 12#hive通过dfs命令查看hdfs文件0: jdbc:hive2://node01:10000&gt; dfs -ls /; 123456789100: jdbc:hive2://node01:10000&gt; dfs -ls /user/hive/warehouse/itheima.db/stu_buck1/dt=2018-02-27/country=china;+--------------------------------------------------------------------------------------------------------------------------------------------+--+| DFS Output |+--------------------------------------------------------------------------------------------------------------------------------------------+--+| Found 3 items || -rwxr-xr-x 2 root supergroup 193 2018-02-27 08:12 /user/hive/warehouse/itheima.db/stu_buck1/dt=2018-02-27/country=china/000000_0 || -rwxr-xr-x 2 root supergroup 170 2018-02-27 08:12 /user/hive/warehouse/itheima.db/stu_buck1/dt=2018-02-27/country=china/000001_0 || -rwxr-xr-x 2 root supergroup 164 2018-02-27 08:12 /user/hive/warehouse/itheima.db/stu_buck1/dt=2018-02-27/country=china/000002_0 |+--------------------------------------------------------------------------------------------------------------------------------------------+--+4 rows selected (0.023 seconds) ##hive之本地模式 hive的本地模式默认是不开启的 123&gt; #通过设置参数开启本地模式&gt; set hive.exec.mode.local.auto=true;&gt; &gt; 是否自动开启hive的本地执行模式：就是以进程模拟的形式模拟出一套MR执行的环境是否自动开启的是有条件的： 12345678&gt; #1.job的输入数据大小必须小于参数：&gt; #(默认128MB)数据量小&gt; hive.exec.mode.local.auto.inputbytes.max&gt; #2.job的map数必须小于参数：&gt; #(默认4)&gt; hive.exec.mode.local.auto.tasks.max&gt; #3.job的reduce数必须为0或者1&gt; hive会根据每次任务自动判断是否启用本地模式；如果不满足hive还是跑集群模式（把组装好的mr程序提交给yarn） 本地模式只是在本地测试为了方便和高效测试而开启的，在生产集群环境上禁止开启 Number of reduce tasks not specified. Estimated from input data size: 1INFO : In order to change the average load for a reducer (in bytes):INFO : set hive.exec.reducers.bytes.per.reducer=INFO : In order to limit the maximum number of reducers:INFO : set hive.exec.reducers.max=INFO : In order to set a constant number of reducers:INFO : set mapreduce.job.reduces= 0: jdbc:hive2://node01:10000&gt; select * from stu_buck1 sort by(sage);INFO : Number of reduce tasks not specified. Estimated from input data size: 1INFO : In order to change the average load for a reducer (in bytes):INFO : set hive.exec.reducers.bytes.per.reducer=INFO : In order to limit the maximum number of reducers:INFO : set hive.exec.reducers.max=INFO : In order to set a constant number of reducers:INFO : set mapreduce.job.reduces=INFO : number of splits:1INFO : Submitting tokens for job: job_1519711328851_0001INFO : The url to track the job: http://node01:8088/proxy/application_1519711328851_0001/INFO : Starting Job = job_1519711328851_0001, Tracking URL = http://node01:8088/proxy/application_1519711328851_0001/INFO : Kill Command = /export/servers/hadoop/bin/hadoop job -kill job_1519711328851_0001INFO : Hadoop job information for Stage-1: number of mappers: 1; number of reducers: 1INFO : 2018-02-27 14:03:02,701 Stage-1 map = 0%, reduce = 0%INFO : 2018-02-27 14:03:18,322 Stage-1 map = 100%, reduce = 0%, Cumulative CPU 2.22 secINFO : 2018-02-27 14:03:31,264 Stage-1 map = 100%, reduce = 100%, Cumulative CPU 4.75 secINFO : MapReduce Total cumulative CPU time: 4 seconds 750 msecINFO : Ended Job = job_1519711328851_0001 create table stu_buck000(Sno int,Sname string,Sex string,Sage int,Sdept string)clustered by(Sno)sorted by(Sno DESC)into 4 bucketsrow format delimitedfields terminated by ‘,’; hiveSQL与SQL格式化日期 1234567891011121314--hive SQLSELECT DATE_FORMAT(current_timestamp(),'yyyy-MM-dd HH:mm:ss') AS datesFROM dual; --2018-02-27 15:25:05SELECT DATE_FORMAT(current_timestamp(),'y-MM-d H:m:s') AS datesFROM dual; --2018-02-27 15:25:42--SQLSELECT name, url, DATE_FORMAT(Now(),'%Y-%m-%d') AS datesFROM Websites; --2018-02-27]]></content>
      <categories>
        <category>bigdata</category>
      </categories>
      <tags>
        <tag>bigdata</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[术语解释]]></title>
    <url>%2F2018%2F03%2F12%2Fterm-interpretation%2F</url>
    <content type="text"><![CDATA[#术语解释 主从主备读写分离(database)水平扩展vs垂直扩展 水平扩展(横向扩展) 添加组件 垂直扩展(纵向扩展) 提高自身能力 case： 添加多台服务器与提高单台服务器运算存储能力 卡车从A到B运输木材 团队与个人 三个臭皮匠与一个诸葛亮 java，前端，DBA，架构师vs全栈工程师 参考 CAP理论 Consistency一致性、Availability可用性、Partition-tolerance分区可容忍性 ACID 关系型数据库的事务操作遵循ACID原则 指在写入/异动资料的过程中，为保证交易正确可靠所必须具备的四个特性 原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）和持久性（Durability） BASE CAS 浅析数据一致性 数据一致性模型 一些分布式系统通过复制数据来提高系统的可靠性和容错性，并且将数据的不同的副本存放在不同的机器，由于维护数据副本的一致性代价高，因此许多系统采用弱一致性来提高性能，一些不同的一致性模型也相继被提出。 强一致性： 要求无论更新操作是在哪一个副本执行，之后所有的读操作都要能获得最新的数据。 弱一致性：用户读到某一操作对系统特定数据的更新需要一段时间，我们称这段时间为“不一致性窗口”。 最终一致性：是弱一致性的一种特例，保证用户最终能够读取到某操作对系统特定数据的更新。 浅析数据一致性]]></content>
      <categories>
        <category>bigdata</category>
      </categories>
      <tags>
        <tag>bigdata</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDFS浅析]]></title>
    <url>%2F2018%2F03%2F12%2Fhadoop-hdfs%2F</url>
    <content type="text"><![CDATA[HDFS浅析HDFS 基本概念简介 Hadoop Distribute File System，即Hadoop分布式文件系统 Hadoop的核心组件之一 作为最底层的分布式存储服务而存在 主要解决大数据的存储问题 应用前景广泛，为存储和处理大规模数据提供所需的扩展能力 设计目标 硬件故障 故障检测和自动快速恢复 流数据访问 更多是为了批量处理，而非用户交互 重点在数据访问的高吞吐量，而不是数据访问的低延迟 大型数据集 支持大文件 简单一致性模型 write-once-read-many 移动计算比移动数据更便宜 数据不动计算移动 在异构硬件和软件平台上的可移植性 可移植性 缺点 不能做到低延迟 hdfs将重点放在了数据访问的高吞吐量，从而牺牲了低延迟。 对于数据访问低延迟的需求，HBase是更好的选择。 不适合大量小文件存储 由于namenode将文件系统的元数据存储在内存中，因此该文件系统能存储的文件受限于namenode的内存容量，根据经验，每个文件、目录和数据块的存储信息大约占150字节。因此，如果大量的小文件存储，每个小文件会占一个数据块，会使用大量的内存，有可能超过当前硬件的能力。 不适合多用户写入文件，修改文件 Hadoop2.0虽然支持文件的追加功能，但是还是不建议对HDFS上的 文件进行修改，因为效率低。 对于上传到HDFS上的文件，不支持修改文件，HDFS适合一次写入，多次读取的场景。 HDFS不支持多用户同时执行写操作，即同一时间，只能有一个用户执行写操作。 重要特性 文件系统 用于存储文件 通过统一命名空间目录树定位文件 分布式 由很多服务器联合起来实现其功能，集群中的服务器有各自的角色 master/slave架构 HDFS采用master/slave架构。 一般一个HDFS集群是有一个namenode和一定数目的datanode组成。 namenode是HDFS集群的主节点，datanode是HDFS集群的从节点，两种角色各司其职，共同协调完成分布式文件存储服务。 分块存储 HDFS中的文件在物理上是分块（block）存储的。 块大小通常可以通过配置参数来规定，默认大小在hadoop2.x版本中是128M，在hadoop1.x版本中是64M。 参数设置 设置每个namenode节点和datanode节点的hdfs-site.xml文件，将文件中的dfs.block.size属性值改为33554432（32M）单位大小为比特（B），重启集群。 name value description dfs.blocksize 134217728 The default block size for new files, in bytes. You can use the following suffix (case insensitive): k(kilo), m(mega), g(giga), t(tera), p(peta), e(exa) to specify the size (such as 128k, 512m, 1g, etc.), Or provide complete size in bytes (such as 134217728 for 128 MB). 123456789101112131415&gt; # hadoop1.x&gt; &lt;configuration&gt;&gt; &lt;property&gt;&gt; &lt;name&gt;dfs.block.size&lt;/name&gt;&gt; &lt;value&gt;33554432&lt;/value&gt;&gt; &lt;/property&gt;&gt; &lt;/configuration&gt;&gt; # hadoop2.x中128M&gt; &lt;configuration&gt;&gt; &lt;property&gt;&gt; &lt;name&gt;dfs.blocksize&lt;/name&gt;&gt; &lt;value&gt;134217728&lt;/value&gt;&gt; &lt;/property&gt;&gt; &lt;/configuration&gt;&gt; 命名空间（namespace） HDFS支持传统的层次型文件组织结构。用户或者应用程序可以创建目录，然后将文件保存在这些目录里。文件系统名字空间的层次结构和大多数现有的文件系统类似：用户可以创建、删除、移动或重命名文件。 namenode负责维护文件系统的名字空间，任何对文件系统名字空间或属性的修改都将被namenode记录下来。 HDFS会给客户端提供一个统一的抽象目录树，客户端通过路径来访问文件，形如：hdfs://namenode:port/dir-a/dir-b/dir-c/file.data。 namenode元数据管理 我们把目录结构及文件分块位置信息叫做元数据。 Namenode 负责维护整个hdfs文件系统的目录树结构，以及每一个文件所对应的block块信息（block的id及所在的datanode服务器）。 datanode数据存储 文件的各个block的具体存储管理由datanode节点承担。 每一个block都可以在多个datanode上。 Datanode需要定时向Namenode汇报自己持有的block信息。 存储多个副本（副本数量也可以通过参数设置dfs.replication，默认是3）。 副本机制 为了容错，文件的所有block都会有副本。每个文件的block大小和副本系数都是可配置的。应用程序可以指定某个文件的副本数目。副本系数可以在文件创建的时候指定，也可以在之后改变。 一次写入，多次读出 HDFS是设计成适应一次写入，多次读出的场景，且不支持文件的修改。 正因为如此，HDFS 适合用来做大数据分析的底层存储服务，并不适合用来做网盘等应用，因为修改不方便，延迟大，网络开销大，成本太高。 HDFS设置block的目的 参考链接 为什么64MB(或128MB或256MB)是最优选择？ 为什么不能远少于64MB(或128MB或256MB) （普通文件系统的数据块大小一般为4KB） 1.减少硬盘寻道时间 HDFS设计前提是支持大容量的流式数据操作，所以即使是一般的数据读写操作，涉及到的数据量都是比较大的。假如数据块设置过少，那需要读取的数据块就比较多，由于数据块在硬盘上非连续存储，普通硬盘因为需要移动磁头，所以随机寻址较慢，读越多的数据块就增大了总的硬盘寻道时间。当硬盘寻道时间比io时间还要长的多时，那么硬盘寻道时间就成了系统的一个瓶颈。合适的块大小有助于减少硬盘寻道时间，提高系统吞吐量。 2.减少Namenode内存消耗 对于HDFS，他只有一个Namenode节点，他的内存相对于Datanode来说，是极其有限的。然而，namenode需要在其内存FSImage文件中中记录在Datanode中的数据块信息，假如数据块大小设置过少，而需要维护的数据块信息就会过多，那Namenode的内存可能就会伤不起了。 为什么不能远大于64MB(或128MB或256MB)？ 这里主要从上层的MapReduce框架来讨论 基本操作基本原理NameNode概述]]></content>
      <categories>
        <category>bigdata</category>
      </categories>
      <tags>
        <tag>bigdata</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hadoop专题]]></title>
    <url>%2F2018%2F03%2F12%2Fhadoop%2F</url>
    <content type="text"><![CDATA[#hadoop专题 网络同步集群时钟 yum install ntpdate ntpdate cn.pool.ntp.org 查看java的安装位置which java hadoop版本 官方提供的x86编译版本 如果需要安装x64版本或者适合于自己系统的版本，需要自己编译 修改hadoop的配置文件 hadoop-env.sh 指定java JDK的位置 core-site.xml 指定hdfs所使用的文件系统和hdfs的老大namenode节点 hdfs-site.xml 指定hdfs副本（这里的副本数包括自己）数量，默认是3 mapred-site.xml hadoop2.7.4的目录结构 /export/servers/hadoop/ binetcincludeliblibexecLICENSE.txtlogsNOTICE.txtREADME.txtsbinshare 相关jar包 /export/servers/hadoop/share/hadoop commonhdfshttpfskmsmapreducetoolsyarn hadoop相关配置文件 /export/servers/hadoop/etc/hadoop capacity-scheduler.xmlconfiguration.xslcontainer-executor.cfgcore-site.xmlhadoop-env.cmdhadoop-env.shhadoop-metrics2.propertieshadoop-metrics.propertieshadoop-policy.xmlhdfs-site.xmlhttpfs-env.shhttpfs-log4j.propertieshttpfs-signature.secrethttpfs-site.xmlkms-acls.xmlkms-env.shkms-log4j.propertieskms-site.xmllog4j.propertiesmapred-env.cmdmapred-env.shmapred-queues.xml.templatemapred-site.xmlslavesssl-client.xml.examplessl-server.xml.exampleyarn-env.cmdyarn-env.shyarn-site.xml hadoop相关运行脚本 /export/servers/hadoop/sbin/ distribute-exclude.shhadoop-daemon.shhadoop-daemons.shhdfs-config.cmdhdfs-config.shhttpfs.shkms.shmr-jobhistory-daemon.shrefresh-namenodes.shslaves.shstart-all.cmdstart-all.shstart-balancer.shstart-dfs.cmdstart-dfs.shstart-secure-dns.shstart-yarn.cmdstart-yarn.shstop-all.cmdstop-all.shstop-balancer.shstop-dfs.cmdstop-dfs.shstop-secure-dns.shstop-yarn.cmdstop-yarn.shyarn-daemon.shyarn-daemons.sh hadoop的其他运行脚本 /export/servers/hadoop/bin/ container-executorhadoophadoop.cmdhdfshdfs.cmdmapredmapred.cmdrcctest-container-executoryarnyarn.cmd hadoop集群启动 需要启动HDFS和YARN两个集群 首次启动HDFS集群需要进行格式化（初始化） 因为HDFS在物理上是不存在的，需要一些清理和准备工作 执行命令 hadoop1.x namenode –format```123456&gt;&gt; 或者&gt;&gt; hadoop2.x&gt;&gt; ```hadoop namenode –format 方式一： hdfs集群启动与yarn集群启动 start-dfs.sh start-yarn.sh stop-dfs.sh stop-yarn.sh 方式二： hdfs与yarn集群一键启动 start-all.sh stop-all.sh 方式三： 单节点启动 hadoop-daemon.sh start namenode hadoop-daemon.sh start datanode hadoop-daemon.sh start secondarynamenode yarn-daemon.sh start resourcemanager yarn-daemon.sh start nodemanager jps查看正在运行的java进程 NameNode DataNode SencondaryNameNode ResourceManager NodeManager 通过Web-UI查看 浏览器访问hdfs集群NameNode地址=http://node01:50070/ 浏览器访问yarn集群ResourceManager地址=http://node01:8088/ 单点故障 Hadoop初体验 HDFS的使用 从Linux本地上传一个文本文件到hdfs的/test/input目录下 12hadoop fs -mkdir -p /test/inputhadoop fs -put /root/words.txt /test/input 运行mapreduce程序 在hadoop安装包hadoop2.7.4/share/hadoop/mapreduce目录下有hadoop-mapreduce-examples-2.7.4.jar 计算圆周率PI 12#蒙特卡罗方法估算圆周率hadoop jar /export/server/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.4.jar pi 20 50 HDFS Shell客户端操作 1234567#hadoop1.x#hdfs dfs &lt;args&gt;#hadoop2.x#hadoop fs &lt;args&gt;hadoop fs -ls hdfs://node01:9000/hadoop fs -ls file:///]]></content>
      <categories>
        <category>bigdata</category>
      </categories>
      <tags>
        <tag>bigdata</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式集群]]></title>
    <url>%2F2018%2F03%2F12%2Fdistributed-software-install%2F</url>
    <content type="text"><![CDATA[#分布式集群 ###前置事项 规划集群 Linux存储、系统及版本选择 Ubuntu16.x Centos6.x 主节点一般选大内存，小存储 主节点一般比较消耗内存 一般32G/64G,奢侈128G/256G 硬盘可是视情况选择 数据节点一般选择大存储，小内存 数据节点一般消耗磁盘存储空间 一般是2T/4T 内存4G/8G 安装系统 阿里云选择镜像或者自建集群系统盘安装系统 KVM虚拟化技术 虚拟机安装（VM or Vbox） 网络NAT 配置网关，注意IP地址 可以选择安装单台或者安装完一台后复制多份（修改） 安装节点系统 安装完成后注意事项 修改主机名 临时 1hostname vm01 - 永久 1vim /etc/sysconfig/network &gt; 将12345678910111213141516171819202122232425 &gt; &gt; hosts文件修改后立刻生效 ​- 修改MAC地址 - 方式1 - 如果复制centos - 启动后选择**我已复制** - 删掉```rm -rf /etc/udev/rules.d/70-persistent-net.rules```文件 - 重启后会自动生成对应新文件 - 查看```cat /etc/udev/rules.d/70-persistent-net.rules```文件的MAC地址并记录 - 打开```vim /etc/sysconfig/network-scripts/ifcfg-eth0```修改__HWADDR__，改为刚刚记录下来的MAC地址值 - 重启网络服务或重启该节点服务器生效 ```shell # 重启节点主机 halt shutdown -r now # 重启网络服务 service network stop service network start service network restart - 方式2 - vmware设置-网络适配器-高级-生成MAC地址（多生成几次，以免重复） - 修改MAC地址/etc/udev/rules.d/70-persistent-net.rules```为上面生成的值并删掉多余的eth1123456 或者 - 修改```vim /etc/udev/rules.d/70-persistent-net.rules```文件，删掉eth0相关的配置，将eth1为eth0即可 - 修改```vim /etc/sysconfig/network-scripts/ifcfg-eth0 - 将HWADDR值改成最新生成的MAC地址 - 立即重启-r now```123456789101112131415161718 &gt; MAC地址样例 &gt; &gt; 00:0C:29:CB:E8:AA &gt; 00:0C:29:DA:6B:C9- 修改ifcfg-eth0 ```shell vim /etc/sysconfig/network-scripts/ifcfg-eth0 #修改 DEVICE=&quot;eth0&quot; HWADDR=&quot;00:0C:29:FD:FF:2A&quot; ONBOOT=&quot;yes&quot; IPADDR=192.168.1.31 NETMASK=255.255.255.0 GATEWAY=192.168.1.1 BOOTPROTO=static - 网络接口配置文件说明 12345678910TYPE=Ethernet #网卡类型DEVICE=eth0 #网卡接口名称ONBOOT=yes #系统启动时是否自动加载BOOTPROTO=static #启用地址协议 --static:静态协议 --bootp协议 --dhcp协议IPADDR=192.168.1.11 #网卡IP地址NETMASK=255.255.255.0 #网卡网络地址GATEWAY=192.168.1.1 #网卡网关地址DNS1=10.203.104.41 #网卡DNS地址HWADDR=00:0C:29:13:5D:74 #网卡设备MAC地址BROADCAST=192.168.1.255 #网卡广播地址 - 重启网卡 12/etc/init.d/network stop/etc/init.d/network start - 网络服务的启动与关闭 - 方式1 123service network stop #关闭网络服务service network start #启动网络服务service network restart #重启网络服务 - 方式2 123/etc/init.d/network stop/etc/init.d/network start/etc/init.d/network restart - 网卡接口关闭与激活 12ifdown eth0 #关闭网络ifup eth0 #启动网络 - 网卡状态查询 1service network status - 设置相同时区并永久同步相同时钟 123456# 1.修改时区为Asia/Shanghaicp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime# 2.安装ntp服务器yum install ntp# 3.同步时间命令ntpdate cn.pool.ntp.org - [参考01](http://blog.csdn.net/testcs_dn/article/details/39803919) - [参考02](http://blog.csdn.net/wangmj518/article/details/49683305) 永久关闭放火墙 服务器一般对外网开放某些端口，对内网永久关闭防火墙 12# 临时关闭和永久关闭防火墙service iptables stop &amp;&amp; chkconfig iptables off 配置免密登录 一般是配置主节点到自己及其他从节点的免密登录 也可以配置集群中所有节点自己与自己及其他节点的免密登录 安装一些软件包 配置YUM源 集群搭建需要注意的两点是： 1.关闭内网防火墙 2.时间一致性 windows/Linux OS是hosts文件 位置 windows C:\Windows\System32\drivers\etc\hosts Linux /etc/hosts 作用 加快域名解析 对于要经常访问的网站，我们可以通过在hosts中配置域名和IP的映射关系，提高域名解析速度。由于有了映射关系，当我们输入域名计算机就能很快解析出IP，而不用请求网络上的DNS服务器。 注意：IP与域名中间要有空格，IP地址一定要输入正确，不然就访问不了该网站了，可以通过运行CMD，输入“ping 网站域名” 来获得网站的IP地址！）这样访问速度就会快一点啦，因为他不需要经过DNS域名服务器进行IP地址的解析！ 方便局域网用户 在很多单位的局域网中，会有服务器提供给用户使用。但由于局域网中一般很少架设DNS服务器，访问这些服务器时，要输入难记的IP地址，这对不少人来说相当麻烦，现在可以分别给这些服务器取个容易记住的名字，然后在hosts中建立IP映射，这样以后访问的时候，只要输入这个服务器的名字就行了。 屏蔽网站 现在有很多网站不经过用户同意就将各种各样的插件安装到你的计算机中，其中不乏有病毒木马。对于这些网站我们可以利用Hosts把该网站的域名映射到一个错误的IP或本地计算机的IP，这样就不用访问了。在Windows系统中，约定 127.0.0.1为本地计算机的IP地址, 0.0.0.0是错误的IP地址。 这个网站影响我孩子的健康成长，我要屏蔽他，这样，计算机解析域名www.sex.com 时，就解析到本机IP或错误的IP，达到了屏蔽不健康网站的目的。 现在某些病毒，恶意程序会修改我们的host文件，导致我们无法访问某些网站，当发现某些网站不能访问时，我们可以进入hosts文件进行观察，如果是因为hosts文件造成的网站无法访问，删除病毒添加的语句，就可以对网站进行正常访问。 执行/etc/hosts```centos6.7中的hosts文件内容1234567891011121314151617181920212223&gt; 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4&gt; ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6&gt; 192.168.10.150 node01 zk01 kafka01 storm01&gt; 192.168.10.151 node02 zk02 kafka02 storm02&gt; 192.168.10.152 node03 zk03 kafka03 storm03### CentOS 6 时间，时区，设置修改及时间同步- 时区 - 显示时区 - date --help 获取帮助 - date -R - date +%z ```shell [root@node01 ~]# date -R; date +%z Mon, 29 Jan 2018 06:20:28 +0800 +0800 &gt; 主要就是后面的+0800，东八区 修改时区 1cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 时区的信息存在/usr/share/zoneinfo/下面，本机的时区信息存在/etc/localtime，利用tab键技巧，可以任意修改时区 tzselect，互动式命令 时间 概念：Linux时间有两个 系统时间：也叫软件时间(sys)， 1970年1月1日到当前时间的秒数 BOIS时间：也叫硬件时间(hc) 显示时间 123[root@node01 ~]# date;hwclock -rMon Jan 29 06:37:19 CST 2018Mon 29 Jan 2018 06:37:23 AM CST -0.954874 seconds 设置时间 方式1：无网络环境 1234[root@node01 ~]# date -s 20180201Thu Feb 1 00:00:00 CST 2018[root@node01 ~]# date -s 16:30:00Thu Feb 1 16:30:00 CST 2018 没有网络的情况下可以用这个 方式2：可以连接外网(ntpdate) 1ntpdate time.windows.com &amp;&amp; hwclock -w 连网更新时间，如果成功，将系统时间，写入BOIS hwclock -w 或 hwclock –systohc 可以做到crontab里 方式3：启动ntpd服务，开启后2就不能用了 先用ntpdate更新一下，确保时间不至于差别太大 1234rpm -qa | grep ntp #查询一下可安装了chkconfig --list | grep ntp #看下服务情况chkconifg ntpd onservice ntpd start 或/etc/init.d/ntpd start 必要的话，设置一下/etc/ntp.conf，再把服务reload一下。 ntp的知识参考一下鸟哥的服务器篇 软件相关 安装规划 软件版本号 依赖其他环境或包 软件存放路径 解压安装路径 软件日志文件存放路径 软件临时数据文件存放路径 1234mkdir -p /export/server# 存放软件安装或解压文件mkdir -p /export/software# 存放软件包mkdir -p /export/data# 存放临时数据文件mkdir -p /export/log# 存放日志文件 1mkdir -p /export/server &amp;&amp; mkdir -p /export/software &amp;&amp; mkdir -p /export/data &amp;&amp; mkdir -p /export/log ​ 安装流程 将指定软件包(xxx.tar.gz)下载或者上传到A节点服务器 解压到指定路径 重命名或创建软链接 1234mv zookeeperxxx zkmv jdk1.8xxx jdkln -s zookeeperxxx zkln -s jdk1.8xxx jdk 创建日志文件、临时数据文件等文件的存放路径 修改配置文件 配置环境变量 1vim /etc/profile 按Go跳到文件最后一行 修改host映射 1vim /etc/hosts 分发到集群的其他相关节点 软件包解压安装全路径 临时数据文件创建路径 有的需要自己创建，有的自动创建 有的分发后无需修改，有的分发后需要修改 如果节点环境变量文件相同可以分发，否则最好自己手动配置环境变量 更新环境变量 可以重启或者执行如下命令 1source /etc/profile 可以使用XShell或SecureCRT下面的回话窗口同时在多节点执行命令 自定义启动脚本/一键启动脚本/便捷个性化脚本 JDK8安装 查看是否安装 1rpm -qa | grep java 卸载自带openJDK 12345rpm -e --nodeps java-1.7.0-openjdk-1.7.0.45-2.4.3.3.el6.x86_64 rpm -e --nodeps java-1.6.0-openjdk-1.6.0.0-1.66.1.13.0.el6.x86_64 rpm -e --nodeps tzdata-java-2013g-1.el6.noarch 解压并配置环境变量 123456789# 解压tar -zxvf /export/softwares/jdk-8u144-linux-x64.tar.gz -C /export/serverln -s jdk1.8.0_144 jdk8# 打开环境变量配置文件 vim /etc/profile or vi /etc/profile or gedit /etc/profile 设置jdk环境变量 12345JAVA_HOME=/export/server/jdk1.8.0_144JRE_HOME=/export/server/jdk1.8.0_144/jreCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libPATH=$JAVA_HOME/bin:$PATHexport PATH JAVA_HOME CLASSPATH 12#使jdk环境变量立即生效source /etc/profile 测试jdk安装成功且环境变量配置成功 123456java -version java version "1.8.0_144" Java(TM) SE Runtime Environment (build 1.8.0_144-b01) Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)javac -version javac 1.8.0_144 分发到其他节点 12scp -r /export/server/jdk8 vm02:/export/server/scp /etc/profile vm02:/etc/ ​ mysql安装 redis安装 nginx安装 tomcat安装 solr安装 ELK安装 zookeeper安装 zookeeper安装依赖于java JDK，需要先安装JDK，再解压安装zk，可以使用JDK的jps查看zk进程判断是否运行 下载或上传安装包 解压 1234tar -zxvf zookeeper-3.4.5.tar.gz#或者使用如下命令解压到指定路径#tar -zxvf zookeeper-3.4.5.tar.gz -C /export/servermv zookeeper-3.4.5 zk 修改zookeeper配置文件 123cd /export/server/zk/confcp zoo_sample.cfg zoo.cfgvim zoo.cfg zoo.cfg文件添加如下内容 1234567891011# 客户端连接端口，默认2181,可以省略clientPort = 2181# 存储内存数据库快照的位置和放置事务日志的位置dataDir=/export/data/zookeeper## (2888心跳端口、3888选举端口)# server.x = [主机名]：nnnnn [：nnnnn]# 组成ZooKeeper集合的服务器# zk01,zk02,zk03是配置在/etc/hosts中，可以不单独配置，直接使用原来的node01,node02,node03server.1=zk01:2888:3888server.2=zk02:2888:3888server.3=zk03:2888:3888 创建数据库快照文件存储路径 1mkdir -p /export/data/zookeeper 创建zk集群节点服务器编号文件myid 1echo 1 &gt; /export/server ​ 将zk加入环境变量 12345678vim /etc/profile#按键盘Go到文件末尾新空行#添加如下内容#设置zookeeper环境变量export ZK_HOME=/export/server/zookeeper-3.4.5#或者使用# export ZK_HOME=/export/server/zkexport PATH=$PATH:$JAVA_HOME/bin:$ZK_HOME/bin 执行/etc/profile```使得环境变量立即生效1234567891011121314151617- 分发到zk集群的其他节点```shell#在zoo.cfg文件dataDir=/export/data/zookeeper指定位置创建myid#可以通过scp分发后修改myid文件中的数值或者到对应节点创建myid文件并写入对应编号，注意是依次编号不能重复###zk02节点的zk包和myid文件scp -r /export/server/zk node02:/export/server/scp -r /export/data/zookeeper/myid node02:/export/data/zookeeperecho 2 &gt; /export/data/zookeeper/myid###zk03节点zk包和myid文件scp -r /export/server/zk node03:/export/server/mkdir -p /export/data/zookeeperecho 3 &gt; /export/data/zookeeper/myid#配置或分发zk01环境变量zk02和zk03节点scp /etc/profile node02:/etc/profilescp /etc/profile node03:/etc/profile 测试 输入zk按两次tab键看zk相关命令脚本是否出现 12[root@node02 ~]# zkzkCleanup.sh zkCli.cmd zkCli.sh zkEnv.cmd zkEnv.sh zkServer.cmd zkServer.sh 启动zk集群 分别在zk01、zk02和zk03上执行start```123456```shell[root@node01 ~]# zkServer.sh startJMX enabled by defaultUsing config: /export/servers/zookeeper-3.4.5/bin/../conf/zoo.cfgStarting zookeeper ... STARTED 执行server的进程**QuorumPeerMain**12345```shell[root@node01 ~]# jps1894 QuorumPeerMain1919 Jps 执行zkServer.sh status查看每个zk的运行状态及角色 1234[root@node01 ~]# zkServer.sh statusJMX enabled by defaultUsing config: /export/servers/zookeeper-3.4.5/bin/../conf/zoo.cfgMode: follower 1234[root@node02 ~]# zkServer.sh statusJMX enabled by defaultUsing config: /export/servers/zookeeper-3.4.5/bin/../conf/zoo.cfgMode: leader 1234[root@node03 ~]# zkServer.sh statusJMX enabled by defaultUsing config: /export/servers/zookeeper-3.4.5/bin/../conf/zoo.cfgMode: follower 执行stop```停止zk服务1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495 &gt; 3台zk集群的容错能力是1台（4台也是1） &gt; &gt; 其中一台挂掉后，另外两台可以继续正常工作 &gt; &gt; 如果leader挂掉，重新投票选举leader &gt; &gt; 如果follower挂掉，leader不会改变 &gt; &gt; 如果挂掉两台，剩下的一台zk节点无法正常工作 &gt; &gt; 5台的zk集群的容错能力是2台，即最多允许两台zk节点服务器挂掉还能正常 工作。（6台也是2） &gt; &gt; 小结：zk集群一般是基数台（2n+1）,必须保证半数以上机器存活才能正常工作 ​ &gt; 集群配置参数节选 &gt; &gt; - server.x=[hostname]:nnnnn[:nnnnn], etc &gt; &gt; &gt; (No Java system property) &gt; &gt; &gt; &gt; servers making up the ZooKeeper ensemble. When the server starts up, it determines which server it is by looking for the file myid in the data directory. That file contains the server number, in ASCII, and it should match **x** in **server.x** in the left hand side of this setting. &gt; &gt; &gt; &gt; The list of servers that make up ZooKeeper servers that is used by the clients must match the list of ZooKeeper servers that each ZooKeeper server has. &gt; &gt; &gt; &gt; There are two port numbers **nnnnn**. The first followers use to connect to the leader, and the second is for leader election. The leader election port is only necessary if electionAlg is 1, 2, or 3 (default). If electionAlg is 0, then the second port is not necessary. If you want to test multiple servers on a single machine, then different ports can be used for each server. &gt; &gt; ​ &gt; &gt; - electionAlg &gt; &gt; &gt; (No Java system property) &gt; &gt; &gt; &gt; Election implementation to use. &gt; &gt; &gt; &gt; - A value of &quot;0&quot; corresponds to the original UDP-based version, &gt; &gt; - &quot;1&quot; corresponds to the non-authenticated UDP-based version of fast leader election, &gt; &gt; - &quot;2&quot; corresponds to the authenticated UDP-based version of fast leader election, &gt; &gt; - and &quot;3&quot; corresponds to TCP-based version of fast leader election. &gt; &gt; &gt; &gt; Currently, algorithm 3 is the default &gt; &gt; &gt; &gt; &gt; Note &gt; &gt; &gt; &gt; &gt; &gt; The implementations of leader election 0, 1, and 2 are now **deprecated **. We have the intention of removing them in the next release, at which point only the FastLeaderElection will be available. [集群配置选项](http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_configuration) [electionAlg=0集群无法恢复且日志无限打印的问题](https://issues.apache.org/jira/browse/ZOOKEEPER-2400) - zookeeper的高性能参数配置 &gt; 为了在更新时获得较低的延迟，有一个专用的事务日志目录很重要。默认情况下，事务日志与数据快照和*myid*文件放在同一个目录中。dataLogDir参数指示用于事务日志的不同目录。 - 为什么需要配置两个端口server.1=zk01:2888:3888？ &gt; follower连接到leader并与leader进行通信的TCP连接端口 &gt; &gt; 默认的leader选举也是TCP协议，所以另一个端口作为leader选举端口。**即一个TCP协议通信端口，一个TCP协议leader选举端口（默认electionAlg=3，FastLeaderElection算法）** zookeeper的安装运行- flume安装- hadoop安装- hive安装- azkaban安装- kafka安装- storm安装- sqoop安装- spark安装### 安装方式- 离线安装 - xxx.tar.gz的压缩包需要解压安装，有的需要解压+编译+安装 - rpm文件安装- 在线安装 - 对于某些包或软件可以选择在线安装 - 简单方便 ```shell yum install nc yum install lrzsz 如果yum源中的软件版本过低，不满足需求，需要离线安装]]></content>
      <categories>
        <category>bigdata</category>
      </categories>
      <tags>
        <tag>bigdata</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2F2018%2F02%2F06%2Ftags%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F02%2F06%2FREADME%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[关于_config.yml文件]]></title>
    <url>%2F2018%2F01%2F28%2Fhexo_config.yml%2F</url>
    <content type="text"><![CDATA[主要参数介绍123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Hexo #网站标题subtitle: #网站副标题description: #网站描述author: John Doe #作者language: #语言timezone: #网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.com #你的站点Urlroot: / #站点的根目录permalink: :year/:month/:day/:title/ #文章的 永久链接 格式 permalink_defaults: #永久链接中各部分的默认值# Directory source_dir: source #资源文件夹，这个文件夹用来存放内容public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件。tag_dir: tags # 标签文件夹 archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #Include code 文件夹i18n_dir: :lang #国际化（i18n）文件夹skip_render: #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 # Writingnew_post_name: :title.md # 新文章的文件名称default_layout: post #预设布局titlecase: false # 把标题转换为 title caseexternal_link: true # 在新标签中打开链接filename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false #是否显示草稿post_asset_folder: false #是否启动 Asset 文件夹relative_link: false #把链接改为与根目录的相对位址 future: true #显示未来的文章highlight: #内容中代码块的设置 enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map: #分类别名tag_map: #标签别名# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD #日期格式time_format: HH:mm:ss #时间格式 # Pagination## Set per_page to 0 to disable paginationper_page: 10 #分页数量pagination_dir: page # Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape #主题名称# Deployment## Docs: https://hexo.io/docs/deployment.html# 部署部分的设置deploy: type: #类型，常用的git _config.yml 的YAML语法格式 _config.yml配置官方文档]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo常用命令]]></title>
    <url>%2F2018%2F01%2F28%2Fhexo%2F</url>
    <content type="text"><![CDATA[常见命令1234567891011hexo new "postName" #新建文章hexo new page "pageName" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本#生成博文是执行如下命令#根据 gulpfile.js 中的配置#对 public 目录中的静态资源文件进行压缩hexo g &amp;&amp; gulp 缩写1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合命令12hexo s -g #生成并本地预览hexo d -g #生成并上传 修改后本地测试已经变化但是提交到github上无变化，请依次执行下面命令 123hexo clean hexo g hexo d 参考Hexo的配置使用]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zookeeper]]></title>
    <url>%2F2018%2F01%2F28%2Fzookeeper%2F</url>
    <content type="text"><![CDATA[zookeeper是什么 一个分布式协调服务的开源框架（抽象/高大上） 一个分布式小文件存储系统（形象具体） 数据存储方式 文件系统目录树 便于对树节点进行有效管理 便于监控维护存储的数据的状态变化，从而达到基于数据的集群管理 统一命名服务 分布式配置管理 分布式消息队列 分布式锁 分布式协调 主要作用 解决分布式集群中应用系统一致性问题（避免同时操作同一数据造成脏读等） 角色与职能 leader 集群工作的核心 事务请求（写操作）的唯一调度者和处理者，保证集群事务处理的顺序性 集群内部各个服务器的调度者 写操作 create setData delete follower 处理客户端非事务请求（读操作），事务请求转发给leader 参与集群leader的选举投票 observer 观察zookeeper集群的最新状态变化并同步 可以独立处理客户端的非事务请求，事务请求转发给leader 不参与任何形式的投票 通常在不影响集群事务处理能力的前提下提升的非事务处理能力 case:某电商项目读压力较大，可以在zk cluster中添加若干台server充当observer，用于水平扩展 特性 全局数据一致性 每个server保存一份相同的数据副本，client连接到哪个server，看到的数据都一致 可靠性 如果消息被其中一台服务器接收，那么将被所有服务器接收 顺序性 全局有序 如果在一台服务器上，消息a在消息b前发布，那么在所有server上都是消息a在消息b前发布 偏序 如果一消息b在消息a之后被同一发送者发布，那么a必将排在b的前面 数据更新的原子性 一次数据更新要么全部成功（半数以上节点成功），要么全部失败，没有中间状态 实时性 zookeeper保证客户端在一定的时间间隔内获得服务器的更新信息或者服务器的失效信息 安装​ 以下是设置服务器的步骤，这些服务器将成为整体的一部分。这些步骤应该在集合中的每个主机上执行： 安装Java JDK。您可以在您的系统上使用本地打包系统，或从以下位置下载JDK： http://java.sun.com/javase/downloads/index.jsp 设置Java堆大小。这是非常重要的，以避免交换，这将严重降低ZooKeeper性能。要确定正确的值，请使用负载测试，并确保您远低于可能导致交换的使用限制。保守 - 对于4GB机器，最大堆大小为3GB。 安装ZooKeeper服务器包。它可以从以下网址下载： http://zookeeper.apache.org/releases.html 创建一个配置文件。这个文件可以被称为任何东西。使用以下设置作为起点： 12345678tickTime = 2000 dataDir = / var / lib / zookeeper / clientPort = 2181 initLimit = 5 syncLimit = 2 server.1 = zoo1：2888：3888 server.2 = zoo2：2888：3888 server.3 = zoo3：2888：3888 您可以在配置参数部分找到这些配置和其他配置设置的含义。一个字虽然在这里几个： 每个属于ZooKeeper集合的机器都应该知道集合中的每一台机器。您可以使用server.id = host：port：port格式的一系列行完成此操作。参数主机和端口是直接的。通过创建一个名为myid的文件（每个服务器驻留在该服务器的数据目录中），将服务器ID分配给每台计算机 ，如配置文件参数dataDir所指定的。 myid文件由一行仅包含该机器ID的文本组成。所以服务器1的myid将包含文本“1”，而不是别的。id在集合中必须是唯一的，并且应该具有1到255之间的值。 如果你的配置文件设置好了，你可以启动一个ZooKeeper服务器： $ java -cp zookeeper.jar：lib / slf4j-api-1.6.1.jar：lib / slf4j-log4j12-1.6.1.jar：lib / log4j-1.2.15.jar：conf \ org.apache.zookeeper。 server.quorum.QuorumPeerMain zoo.cfg QuorumPeerMain启动一个ZooKeeper服务器， JMX 管理bean也被注册，允许通过一个JMX管理控制台进行管理。该ZooKeeper的JMX文件包含有关使用JMX管理ZooKeeper的细节。 有关启动服务器实例的示例，请参阅发行版中包含的脚本bin / zkServer.sh。 通过连接到主机来测试您的部署： 在Java中，您可以运行以下命令来执行简单的操作： $ bin / zkCli.sh -server 127.0.0.1:2181 Apache官方安装说明 安装方式 单机模式 伪集群模式 集群模式 运行模式 单机模式 standalone mode 便于评估、开发和测试 主要用于开发测试环境 集群模式 replicated mode 用于生产环境 一个zookeeper集群的机器数 仲裁集（quorum） 有相同的配置文件副本 至少需要三台服务器，为了更好的容错能力和更大的可靠性可以配置五台 官方强烈推荐基数台 半数以上节点存活才能正常运行 3台服务器和4台服务器的的容灾能力是一样的，所以为了节省服务器资源，一般我们采用奇数个数，作为服务器部署个数 Note As mentioned in the ZooKeeper Getting Started Guide , a minimum of three servers are required for a fault tolerant clustered setup, and it is strongly recommended that you have an odd number of servers. Usually three servers is more than enough for a production install, but for maximum reliability during maintenance, you may wish to install five servers. With three servers, if you perform maintenance on one of them, you are vulnerable to a failure on one of the other two servers during that maintenance. If you have five of them running, you can take one down for maintenance, and know that you’re still OK if one of the other four suddenly fails. Your redundancy considerations should include all aspects of your environment. If you have three ZooKeeper servers, but their network cables are all plugged into the same network switch, then the failure of that switch will take down your entire ensemble. 容错集群设置至少需要三台服务器，强烈建议您有奇数个服务器 通常情况下，对于一个生产环境安装三台服务器足够了，但是在运维期间，为了最大的可靠性，你可能希望安装五台服务器。在三台服务器的集群中，如果你正在其中一台上进行维护操作，在维护期间，你很容易受到其他两台服务器中的一台出现故障的影响。如果有五台服务器正在运行，你可以维护其中一台并且知道如果其他四台中的一台宕机仍然可以正常工作。 你的冗余考虑应该包括所有环境方面的因素。如果你有三台zookeeper服务器，但他们的网络电缆都插进了相同的网络交换机，那么交换机故障会让你的整个集群宕掉。 请重点参阅 其他 主从vs主备 主从：各个节点数据不一致 主备：各个服务器的数据一致，互为副本 数据副本 包括自己 选举机制相关协议ZAB（zookeeper automatic broadcast） ZAB 协议 相关算法 Paxos FastLeaderElection ZooKeeper、Eureka对比 Eureka本身是Netflix开源的一款提供服务注册和发现的产品，并且提供了相应的Java封装。在它的实现中，节点之间相互平等，部分注册中心的节点挂掉也不会对集群造成影响，即使集群只剩一个节点存活，也可以正常提供发现服务。哪怕是所有的服务注册节点都挂了，Eureka Clients（客户端）上也会缓存服务调用的信息。这就保证了我们微服务之间的互相调用足够健壮。 Zookeeper主要为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册。曾经是Hadoop项目中的一个子项目，用来控制集群中的数据，目前已升级为独立的顶级项目。很多场景下也用它作为Service发现服务解决方案。 在分布式系统中有个著名的CAP定理（C-数据一致性；A-服务可用性；P-服务对网络分区故障的容错性，这三个特性在任何分布式系统中不能同时满足，最多同时满足两个）； ZooKeeper基于CP，不保证高可用，如果zookeeper正在选主，或者Zookeeper集群中半数以上机器不可用，那么将无法获得数据。Eureka基于AP，能保证高可用，即使所有机器都挂了，也能拿到本地缓存的数据。作为注册中心，其实配置是不经常变动的，只有发版和机器出故障时会变。对于不经常变动的配置来说，CP是不合适的，而AP在遇到问题时可以用牺牲一致性来保证可用性，既返回旧数据，缓存数据。 所以理论上Eureka是更适合作注册中心。而现实环境中大部分项目可能会使用ZooKeeper，那是因为集群不够大，并且也比基本不会遇到用做注册中心的机器一半以上都挂了的情况。所以实际上也没什么大问题。 参考 原文地址 java葵花宝典]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F01%2F28%2F%E5%89%8D%E7%AB%AF%2FHexo%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>前端</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
